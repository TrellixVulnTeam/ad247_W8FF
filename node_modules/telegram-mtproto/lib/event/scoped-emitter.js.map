{"version":3,"sources":["../../src/event/scoped-emitter.js"],"names":["normalizeScope","scope","reduceStarter","acc","val","concat","combineScope","scopes","reduce","ScopedEmitter","constructor","parent","on","event","listener","fullEvent","root","off","join","emit","values","Predicate","prototype","contramap","f","x","EventScope","of","list","Array","isArray","map","fn","value","e","ap","equals","entries","index","str","empty","joined","emitScope","es","em","data","fromScope","ex","mp","ex1"],"mappings":"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","file":"scoped-emitter.js","sourcesContent":["//@flow\n//@ts-check\n\nimport type { EventEmitterType, EventID, Listener } from 'eventemitter2'\nimport { tagged } from 'daggy'\nimport { fromEvents } from 'kefir'\nimport arrify from '../util/arrify'\n\nconst normalizeScope = (scope: EventID) => arrify(scope)\n\nconst reduceStarter: string[] = []\n\nconst combineScope = (...scopes: EventID[]) => scopes.reduce(\n  (acc, val) => acc.concat(normalizeScope(val)),\n  reduceStarter\n)\n\nclass ScopedEmitter implements EventEmitterType {\n  scope: string[]\n  root: EventEmitterType\n  constructor(scope: EventID, parent: EventEmitterType) {\n    if (parent instanceof ScopedEmitter) {\n      this.root = parent.root\n      this.scope = combineScope(parent.scope, scope)\n    } else {\n      this.scope = normalizeScope(scope)\n      this.root = parent\n    }\n  }\n\n  on = (event: EventID, listener: Listener) => {\n    const fullEvent = this.scope.concat(normalizeScope(event))\n    // console.log('on', 'event', event, 'fullEvent', fullEvent, 'scope', this.scope, normalizeScope(event))\n    return this.root.on(fullEvent, listener)\n  }\n  off = (event: string, listener: Listener) => {\n    const fullEvent = [...this.scope, event].join('.')\n    return this.root.off(fullEvent, listener)\n  }\n  emit = (event: EventID, ...values: any[]) => {\n    const fullEvent = this.scope.concat(normalizeScope(event))\n    // console.log('emit', 'event', event, 'fullEvent', fullEvent, 'scope', this.scope, normalizeScope(event))\n    return this.root.emit(fullEvent, ...values)\n  }\n}\n\n\nconst Predicate = tagged('Predicate', ['f'])\n\n// Make a Predicate that runs `f` to get\n// from `b` to `a`, then uses the original\n// Predicate function!\n// contramap :: Predicate a ~> (b -> a)\n//                          -> Predicate b\nPredicate.prototype.contramap =\n  function(f) {\n    return Predicate(\n      x => this.f(f(x))\n    )\n  }\n\n\n\ninterface ScopeType {\n  value: string[],\n  static of(val: string[]): ScopeType,\n  map(fn: (val: string[]) => string[]): ScopeType,\n  concat(e: ScopeType): ScopeType,\n  ap(root: EventEmitterType): Emitter,\n  equals(val: ScopeType): boolean\n}\n\n\n\n\ntype Emitter = <V>(val: V) => boolean\n\nexport class EventScope {\n  value: string[]\n  joined: string\n  static of(val: string[] | string) {\n    let list\n    if (Array.isArray(val))\n      list = val\n    else\n      list = [val]\n    return new EventScope(list)\n  }\n  map(fn: (val: string[]) => string[]) {\n    return EventScope.of(fn(this.value))\n  }\n  concat(e: ScopeType) {\n    return EventScope.of([...this.value, ...e.value])\n  }\n  ap<T>(fn: (list: string[]) => T): T {\n    return fn(this.value)\n  }\n  equals(scope: EventScope) {\n    for (const [index, str] of this.value.entries())\n      if (str !== scope.value[index])\n        return false\n    return true\n  }\n  static empty() {\n    return EventScope.of([])\n  }\n  constructor(val: string[]) {\n    this.value = val\n    this.joined = val.join('.')\n  }\n}\n\nexport const emitScope =\n  (es: EventScope) =>\n    (em: EventEmitterType) =>\n      <-T>(data: T) => em.emit(es.value, data)\n\nexport const fromScope =\n  (es: EventScope) =>\n    (em: EventEmitterType) =>\n      fromEvents(em, es.joined)\n\nconst ex = EventScope.of(['uid', 'scope'])\n\nconst mp = (val: string[]) => [val[0], 'a']\nconst ex1 = ex.map(mp)\nexport default ScopedEmitter\n"]}