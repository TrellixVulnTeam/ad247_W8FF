'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _most = require('most');

var _configProvider = require('../config-provider');

var _configProvider2 = _interopRequireDefault(_configProvider);

var _makeEventStream = require('./make-event-stream');

var _rpc = require('./rpc');

var _request = require('../service/main/request');

var _request2 = _interopRequireDefault(_request);

var _request3 = require('../service/api-manager/request');

var _request4 = _interopRequireDefault(_request3);

var _networker = require('../service/networker');

var _networker2 = _interopRequireDefault(_networker);

var _netMessage = require('../service/networker/net-message');

var _error = require('../error');

var _dcStoreKeys = require('../util/dc-store-keys');

var _dcStoreKeys2 = _interopRequireDefault(_dcStoreKeys);

var _mtprotoLogger = require('mtproto-logger');

var _mtprotoLogger2 = _interopRequireDefault(_mtprotoLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
// import { taggedSum } from 'daggy'

// import { EventScope } from './scoped-emitter'

var log = _mtprotoLogger2.default`stream-bus`;

/*
const makeStateScopes = (uid: string) => {
  const uidScope = EventScope.of(uid)
  const stateScope = EventScope.of('state')
  const messagesScope = EventScope.of('messages')
  const requestsScope = EventScope.of('requests')
  const stateMessages = stateScope.concat(messagesScope)
  const stateRequests = stateScope.concat(requestsScope)
  const fullScope = {
    requests: uidScope.concat(stateRequests).joined,
    messages: uidScope.concat(stateMessages).joined,
  }

  return fullScope
}*/

function _ref(e) {
  return console.log(e);
}

function _ref2(value) {
  return value.isAPI;
}

function _ref3(value) {
  return !value.isAPI;
}

function _ref6(error) {
  return error.code === 500 && error.type === 'AUTH_RESTART';
}

function _ref11(rs) {
  return setTimeout(rs, 100);
}

function* _ref17({
  dc,
  req,
  apiReq,
  error
}) {
  // const mainDc  = await ctx.storage.get('dc')
  // if (dc === mainDc) {

  // } else {

  // }
}

function _ref18() {
  var _ref16 = _asyncToGenerator(_ref17);

  return function (_x5) {
    return _ref16.apply(this, arguments);
  };
}

var createStreamBus = ctx => {
  var emitter = _configProvider2.default.rootEmitter(ctx.uid);
  var bus = makeStreamMap(emitter);

  // const baseState = fromEvents(
  //   ctx.emitter,
  //   [ctx.uid, 'base'].join('.'),
  //   (str: BaseType) => str
  // ).toProperty((): BaseType => 'INIT')
  bus.baseState.onValue(log`base state`);
  bus.baseState.onValue(_ref);
  // const stateScopes = makeStateScopes(ctx.uid)

  // bus.scopes = {
  //   messages: fromEvents(ctx.emitter, stateScopes.messages),
  //   requests: fromEvents(ctx.emitter, stateScopes.requests),
  // }

  // pushMessage.onValue(log('push message'))

  bus.responseRaw.onValue(log('raw response'));
  bus.responseRaw.onError(log('raw error'));

  bus.incomingMessage.onValue(log('incoming message'));

  var state = ctx.state;

  bus.incomingMessage.observe({
    value(val) {
      // ctx.state.messages.delete(val.message.msg_id)
      var networker = state.threads.get(val.threadID);
      if (networker == null) return;
      log('observer', 'type')(val.message._, networker.dcID);
    }
  });

  bus.newNetworker.observe(networker => {
    log('new networker')(networker);
    state.threads.set(networker.threadID, networker);
  });

  bus.messageIn.onValue(log('message in'));

  var apiOnly = bus.messageIn.filter(_ref2);
  var mtOnly = bus.messageIn.filter(_ref3);

  apiOnly.observe({
    value(val) {
      ctx.state.messages.set(val.msg_id, val);
    }
  });
  mtOnly.observe({
    value(val) {
      ctx.state.messages.set(val.msg_id, val);
    }
  });

  function* _ref5(data) {
    log('rpc result')(data);
    data.sentMessage.deferred.resolve(data.result);
    ctx.state.messages.delete(data.sentMessage.msg_id);
    var requestID = data.sentMessage.requestID;
    if (typeof requestID !== 'string') return;
    var req = ctx.state.requests.get(requestID);
    if (!req) {
      // data.sentMessage.deferred.reject('No such request!')
      return log('on rpc result error')('req', req);
    }
    req.defer.resolve(data.result);
    ctx.state.requests.delete(requestID);
  }

  bus.rpcResult.observe((() => {
    var _ref4 = _asyncToGenerator(_ref5);

    return function (_x) {
      return _ref4.apply(this, arguments);
    };
  })());

  bus.rpcError.onValue(log('rpc error'));

  var isAuthRestart = _ref6;

  function* _ref9(_ref8) {
    var { error } = _ref8,
        data = _objectWithoutProperties(_ref8, ['error']);

    if ((0, _rpc.isFileMigrateError)(error)) {
      var newDc = (0, _rpc.getFileMigrateDc)(error);
      if (typeof newDc !== 'number') throw error;
      if (!ctx.state.messages.has(data.message.req_msg_id)) {
        data.sentMessage.deferred.reject(error);
        return log('on file migrate error')(data.message.req_msg_id, 'req_msg_id not found');
      }
      var msg = ctx.state.messages.get(data.message.req_msg_id);
      if (!msg || !msg.requestID || typeof msg.requestID !== 'string') {
        data.sentMessage.deferred.reject(error);
        return log('on file migrate error')('msg', msg);
      }
      var _req = ctx.state.requests.get(msg.requestID);
      if (!_req) {
        data.sentMessage.deferred.reject(error);
        return log('on file migrate error')('req', _req);
      }
      _req.options.dc = newDc;
      log('file migrate', 'req')(_req);
      log('on file migrate restart')('before end');
      yield ctx.api.invokeNetRequest(_req);
    }if ((0, _rpc.isMigrateError)(error)) {
      var _newDc = (0, _rpc.getMigrateDc)(error);
      if (typeof _newDc !== 'number') throw error;
      yield ctx.storage.set('dc', _newDc);
      if (!ctx.state.messages.has(data.message.req_msg_id)) {
        data.sentMessage.deferred.reject(error);
        return log('on migrate error')(data.message.req_msg_id, 'req_msg_id not found');
      }
      var _msg = ctx.state.messages.get(data.message.req_msg_id);
      if (!_msg || !_msg.requestID || typeof _msg.requestID !== 'string') {
        data.sentMessage.deferred.reject(error);
        return log('on migrate error')('msg', _msg);
      }
      var _req2 = ctx.state.requests.get(_msg.requestID);
      if (!_req2) {
        data.sentMessage.deferred.reject(error);
        return log('on migrate error')('req', _req2);
      }
      _req2.options.dc = _newDc;
      log('migrate', 'req')(_req2);
      log('on migrate restart')('before end');
      yield ctx.api.invokeNetRequest(_req2);
    } else if (isAuthRestart(error)) {
      if (!ctx.state.messages.has(data.message.req_msg_id)) {
        data.sentMessage.deferred.reject(error);
        return log('error', 'auth restart')(data.message.req_msg_id, 'req_msg_id not found');
      }
      var _msg2 = ctx.state.messages.get(data.message.req_msg_id);
      if (!_msg2 || !_msg2.requestID) {
        data.sentMessage.deferred.reject(error);
        return log('error', 'auth restart')('no requestID msg', _msg2);
      }
      var _req3 = ctx.state.requests.get(_msg2.requestID);
      if (!_req3) {
        data.sentMessage.deferred.reject(error);
        return log('error', 'on auth restart')('no request info', _msg2);
      }
      var { authKey, saltKey } = (0, _dcStoreKeys2.default)(data.networkerDC);
      log('on auth restart')(authKey, saltKey);
      yield ctx.storage.remove(authKey, saltKey);
      log('on auth restart')('before end');
      yield ctx.api.doAuth();
      yield ctx.api.invokeNetRequest(_req3);
    } else if (error.code === 401) {

      log('rpc', 'auth key unreg')(data.sentMessage);
      var reqId = data.sentMessage.requestID;
      if (!reqId) {
        data.sentMessage.deferred.reject(error);
        return log('error', 'auth key unreg')('no requestID msg', data.sentMessage);
      }
      var _dc = data.sentMessage.dc;
      var _req4 = ctx.state.requests.get(reqId);
      if (!_req4 || !_dc) {
        data.sentMessage.deferred.reject(error);
        return log('error', 'on auth key unreg')('no request info', _dc, reqId);
      }

      // const { authKey, saltKey } = dcStoreKeys(dc)
      // await ctx.storage.remove(authKey)
      var thread = ctx.state.threads.get(data.threadID);
      if (!thread) {
        data.sentMessage.deferred.reject(error);
        return log('error', 'on auth key unreg')('no thread', _dc, data.threadID);
      }
      // thread.connectionInited = false
      ctx.api.authBegin = false;
      log('on auth key unreg')('before end');
      var nearest = yield ctx.storage.get('nearest_dc');
      yield ctx.storage.set('dc', nearest);
      // await new Promise(rs => setTimeout(rs, 1e3))
      _req4.options.dc = nearest;
      yield ctx.api.doAuth();
      yield ctx.api.invokeNetRequest(_req4);
    } else {
      log('rpc', 'unhandled')(data);
      data.sentMessage.deferred.reject(error);
    }
  }

  bus.rpcError.observe((() => {
    var _ref7 = _asyncToGenerator(_ref9);

    return function (_x2) {
      return _ref7.apply(this, arguments);
    };
  })());

  bus.netMessage.onValue(message => {
    log('net message')(message);
    var req = ctx.state.messages.get(message.msg_id);
    log('req')(req);
  });

  bus.netMessage.onValue(log('new request'));

  function* _ref12(netReq) {
    if (state.requests.has(netReq.requestID)) return log('request', 'repeat')(netReq);
    ctx.state.requests.set(netReq.requestID, netReq);
    var dc = netReq.options.dc;
    if (!dc || dc === '@@home') {
      var fromStore = yield ctx.storage.get('dc');
      dc = fromStore ? +fromStore : ctx.defaultDC;
    }
    netReq.options.dc = dc;

    log`request, new`(netReq);
    yield new Promise(_ref11);
    ctx.api.invokeNetRequest(netReq);
  }

  bus.newRequest.observe((() => {
    var _ref10 = _asyncToGenerator(_ref12);

    return function (_x3) {
      return _ref10.apply(this, arguments);
    };
  })());

  function _ref14(req) {
    return (0, _most.of)(req).map(ctx.api.invokeNetRequest).awaitPromises();
  }

  function* _ref15({
    threadID,
    networkerDC,
    message,
    messageID
  }) {
    var thread = ctx.state.threads.get(threadID);
    if (!thread) {
      log`new session, error, no thread`(threadID, messageID);
      return;
    }
    yield thread.applyServerSalt(message.server_salt);
    thread.ackMessage(messageID);
    thread.processMessageAck(message.first_msg_id);

    log`new session, handled`(messageID, networkerDC);

    var repeatRequest = _ref14;

    yield (0, _most.from)(ctx.state.requests.values()).debounce(100).map(repeatRequest).mergeConcurrently(1).observe(log`recurring requests`);
  }

  bus.newSession.observe((() => {
    var _ref13 = _asyncToGenerator(_ref15);

    return function (_x4) {
      return _ref13.apply(this, arguments);
    };
  })());

  bus.untypedMessage.observe(log`untyped`);

  bus.noAuth.observe(_ref18());

  return bus;
};

var an = {};

var pushMessageCast = an;
var responseRawCast = an;
var incomingMessageCast = an;
var newNetworkerCast = an;
var rpcResultCast = an;
var untypedMessageCast = an;

var netMessageCast = an;
var newRequestCast = an;
var messageInCast = an;
var newSessionCast = an;
var baseCast = an;
var noAuthCast = an;

function _ref19() {
  return 'INIT';
}

function makeStreamMap(emitter) {
  var getter = (0, _makeEventStream.makeEventStream)(emitter);

  var pushMessage = getter('push-message', pushMessageCast);
  var responseRaw = getter('response-raw', responseRawCast);
  var incomingMessage = getter('incoming-message', incomingMessageCast);
  var newNetworker = getter('new-networker', newNetworkerCast);
  var rpcError = getter('rpc-error', changeRpcError);
  var rpcResult = getter('rpc-result', rpcResultCast);
  var untypedMessage = getter('untyped-message', untypedMessageCast);
  var netMessage = getter('net-message', netMessageCast);
  var newRequest = getter('new-request', newRequestCast);
  var messageIn = getter('message-in', messageInCast);
  var newSession = getter('new-session', newSessionCast);
  var baseState = getter('base', baseCast);
  var noAuth = getter('no-auth', noAuthCast);

  var streamMap = {
    pushMessage,
    responseRaw,
    incomingMessage,
    newNetworker,
    rpcError,
    untypedMessage,
    netMessage,
    newRequest,
    messageIn,
    rpcResult,
    newSession,
    noAuth,
    baseState: baseState.toProperty(_ref19)
  };

  return streamMap;
}

function changeRpcError(_ref20) {
  var { error } = _ref20,
      raw = _objectWithoutProperties(_ref20, ['error']);

  var changed = (0, _rpc.onRpcError)(error);
  var result = Object.assign({}, raw, { error: changed });
  return result;
}

/*type ApiCall = {
  type: 'api-call',
  msg_id: string,
  method: string,
  params: Object,
  options: {
    messageID?: string,
    dcID?: number
  }
}*/

exports.default = createStreamBus;
//# sourceMappingURL=stream-bus.js.map