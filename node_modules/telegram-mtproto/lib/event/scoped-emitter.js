'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fromScope = exports.emitScope = exports.EventScope = undefined;

var _daggy = require('daggy');

var _kefir = require('kefir');

var _arrify = require('../util/arrify');

var _arrify2 = _interopRequireDefault(_arrify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//@ts-check

var normalizeScope = scope => (0, _arrify2.default)(scope);

var reduceStarter = [];

function _ref(acc, val) {
  return acc.concat(normalizeScope(val));
}

var combineScope = (...scopes) => scopes.reduce(_ref, reduceStarter);

class ScopedEmitter {
  constructor(scope, parent) {
    this.on = (event, listener) => {
      var fullEvent = this.scope.concat(normalizeScope(event));
      // console.log('on', 'event', event, 'fullEvent', fullEvent, 'scope', this.scope, normalizeScope(event))
      return this.root.on(fullEvent, listener);
    };

    this.off = (event, listener) => {
      var fullEvent = [...this.scope, event].join('.');
      return this.root.off(fullEvent, listener);
    };

    this.emit = (event, ...values) => {
      var fullEvent = this.scope.concat(normalizeScope(event));
      // console.log('emit', 'event', event, 'fullEvent', fullEvent, 'scope', this.scope, normalizeScope(event))
      return this.root.emit(fullEvent, ...values);
    };

    if (parent instanceof ScopedEmitter) {
      this.root = parent.root;
      this.scope = combineScope(parent.scope, scope);
    } else {
      this.scope = normalizeScope(scope);
      this.root = parent;
    }
  }

}

var Predicate = (0, _daggy.tagged)('Predicate', ['f']);

// Make a Predicate that runs `f` to get
// from `b` to `a`, then uses the original
// Predicate function!
// contramap :: Predicate a ~> (b -> a)
//                          -> Predicate b
Predicate.prototype.contramap = function (f) {
  return Predicate(x => this.f(f(x)));
};

class EventScope {
  static of(val) {
    var list = void 0;
    if (Array.isArray(val)) list = val;else list = [val];
    return new EventScope(list);
  }
  map(fn) {
    return EventScope.of(fn(this.value));
  }
  concat(e) {
    return EventScope.of([...this.value, ...e.value]);
  }
  ap(fn) {
    return fn(this.value);
  }
  equals(scope) {
    for (var _iterator = this.value.entries(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref2 = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref2 = _i.value;
      }

      var [index, str] = _ref2;

      if (str !== scope.value[index]) return false;
    }return true;
  }
  static empty() {
    return EventScope.of([]);
  }
  constructor(val) {
    this.value = val;
    this.joined = val.join('.');
  }
}

exports.EventScope = EventScope;
var emitScope = exports.emitScope = es => em => data => em.emit(es.value, data);

var fromScope = exports.fromScope = es => em => (0, _kefir.fromEvents)(em, es.joined);

var ex = EventScope.of(['uid', 'scope']);

var mp = val => [val[0], 'a'];
var ex1 = ex.map(mp);
exports.default = ScopedEmitter;
//# sourceMappingURL=scoped-emitter.js.map