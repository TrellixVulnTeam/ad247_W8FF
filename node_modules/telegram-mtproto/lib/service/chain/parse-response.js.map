{"version":3,"sources":["../../../src/service/chain/parse-response.js"],"names":["readResponse","response","reader","authKeyStored","authKeyID","fetchIntBytes","Error","msgKey","encryptedData","fetchRawBytes","byteLength","getOffset","authKey","aesKey","aesIv","dataWithPadding","aesDecrypt","getDataWithPad","readHash","currentSession","prevSession","sessionID","messageID","typeBuffer","isInvalidSession","console","warn","seqNo","fetchInt","offset","totalLength","messageBodyLength","messageBody","buffer","paddingLength","hashData","subarray","dataHash","sha1Hash","slice","fetchObject","parsedResponse"],"mappings":"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","file":"parse-response.js","sourcesContent":["//@flow\n\nimport { Deserialization } from '../../tl/index'\nimport { bytesCmp, bytesToHex, convertToUint8Array, bytesToArrayBuffer, bytesFromArrayBuffer } from '../../bin'\nimport CryptoWorker from '../../crypto'\nimport getMsgKeyIv from './msg-key'\nimport { readLong } from '../../tl/reader'\n\ntype ReadResponse = {\n  response: ArrayBuffer | Buffer,\n  reader: Deserialization,\n  authKeyStored: number[]\n}\n\ntype GetDataWithPad = {\n  authKey: Uint8Array,\n  msgKey: Uint8Array,\n  encryptedData: Uint8Array\n}\n\ntype ReadHash = {\n  reader: Deserialization,\n  currentSession: number[],\n  prevSession: number[],\n  dataWithPadding: ArrayBuffer\n}\n\ntype ParsedResponse = {\n  hashData: Uint8Array,\n  msgKey: Uint8Array,\n  reader: Deserialization,\n}\n\n\nexport const readResponse = ({ response, reader, authKeyStored }: ReadResponse) => {\n  const authKeyID = reader.fetchIntBytes(64, 'auth_key_id')\n  if (!bytesCmp(authKeyID, authKeyStored)) {\n    throw new Error(`[MT] Invalid server auth_key_id: ${  bytesToHex(authKeyID)}`)\n  }\n  const msgKey = reader.fetchIntBytes(128, 'msg_key')\n  const encryptedData = reader.fetchRawBytes(\n    response.byteLength - reader.getOffset(),\n    'encrypted_data')\n  return {\n    msgKey,\n    encryptedData\n  }\n}\n\n\nexport const getDataWithPad = async ({ authKey, msgKey, encryptedData }: GetDataWithPad) => {\n  const [aesKey, aesIv] = await getMsgKeyIv(authKey, msgKey, false)\n  const dataWithPadding = await CryptoWorker.aesDecrypt(encryptedData, aesKey, aesIv)\n  return dataWithPadding\n}\n\nexport const readHash = ({ reader, currentSession, prevSession, dataWithPadding }: ReadHash) => {\n  reader.fetchIntBytes(64, 'salt')\n  const sessionID = reader.fetchIntBytes(64, 'session_id')\n  const messageID = readLong(reader.typeBuffer, 'message_id')\n\n  const isInvalidSession = !bytesCmp(sessionID, currentSession) && (!prevSession ||\n    //eslint-disable-next-line\n    !bytesCmp(sessionID, prevSession));\n  if (isInvalidSession) {\n    console.warn('Sessions', sessionID, currentSession, prevSession)\n    throw new Error(`[MT] Invalid server session_id: ${ bytesToHex(sessionID) }`)\n  }\n\n  const seqNo = reader.fetchInt('seq_no')\n\n  let offset = reader.getOffset()\n  const totalLength = dataWithPadding.byteLength\n\n  const messageBodyLength = reader.fetchInt('message_data[length]')\n  if (messageBodyLength % 4 ||\n    messageBodyLength > totalLength - offset) {\n    throw new Error(`[MT] Invalid body length: ${  messageBodyLength}`)\n  }\n  const messageBody = reader.fetchRawBytes(messageBodyLength, 'message_data')\n\n  const buffer = bytesToArrayBuffer(messageBody)\n\n  offset = reader.getOffset()\n  const paddingLength = totalLength - offset\n  if (paddingLength < 0 || paddingLength > 15)\n    throw new Error(`[MT] Invalid padding length: ${paddingLength}`)\n  const hashData =\n    convertToUint8Array(dataWithPadding)\n      .subarray(0, offset)\n\n  return {\n    hashData,\n    seqNo,\n    messageID,\n    sessionID,\n    buffer\n  }\n}\n\n\nexport const parsedResponse = async ({ hashData, msgKey, reader }: ParsedResponse) => {\n  const dataHash = await CryptoWorker.sha1Hash(hashData)\n\n  if (!bytesCmp(msgKey, bytesFromArrayBuffer(dataHash).slice(-16))) {\n    console.warn(msgKey, bytesFromArrayBuffer(dataHash))\n    throw new Error('[MT] server msgKey mismatch')\n  }\n  const response = reader.fetchObject('', 'INPUT')\n\n  return response\n}\n"]}