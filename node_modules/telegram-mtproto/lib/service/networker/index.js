'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setUpdatesProcessor = exports.stopAll = exports.startAll = exports.NetworkerThread = undefined;

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _v = require('uuid/v4');

var _v2 = _interopRequireDefault(_v);

var _ramda = require('ramda');

var _timeManager = require('../time-manager');

var _secureRandom = require('../secure-random');

var _secureRandom2 = _interopRequireDefault(_secureRandom);

var _netMessage = require('./net-message');

var _state = require('./state');

var _state2 = _interopRequireDefault(_state);

var _mtprotoShared = require('mtproto-shared');

var _http = require('../../http');

var _tl = require('../../tl');

var _parseResponse = require('../chain/parse-response');

var _performRequest = require('../chain/perform-request');

var _error = require('../../error');

var _configProvider = require('../../config-provider');

var _configProvider2 = _interopRequireDefault(_configProvider);

var _mtprotoLogger = require('mtproto-logger');

var _mtprotoLogger2 = _interopRequireDefault(_mtprotoLogger);

var _bin = require('../../bin');

var _writer = require('../../tl/writer');

var _encryptedMessage = require('../chain/encrypted-message');

var _longPoll = require('../../plugins/long-poll');

var _longPoll2 = _interopRequireDefault(_longPoll);

var _mathHelp = require('../../plugins/math-help');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _bluebird2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _bluebird2.default.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var log = _mtprotoLogger2.default`networker`;

var updatesProcessor = void 0;
var iii = 0;
var akStopped = false;

//eslint-disable-next-line
// const xhrSendBuffer = !isNode && !('ArrayBufferView' in window)

var storeIntString = writer => (value, field) => {
  switch (typeof value) {
    case 'string':
      return (0, _writer.writeBytes)(writer, value, `${field}:string`);
    case 'number':
      return (0, _writer.writeInt)(writer, value, field);
    default:
      throw new Error(`tl storeIntString field ${field} value type ${typeof value}`);
  }
};

function _ref10() {}

class NetworkerThread {
  constructor({
    appConfig,
    storage
  }, dc, authKey, serverSalt, uid) {
    var _this = this;

    this.threadID = (0, _v2.default)();
    this.pendingAcks = [];
    this.state = new _state2.default();
    this.connectionInited = false;
    this.checkConnectionPeriod = 0;
    this.lastServerMessages = [];

    this.checkLongPollCond = () => this.longPoll.pendingTime > (0, _timeManager.tsNow)() || !!this.offline || akStopped;

    this.checkLongPollAfterDcCond = (isClean, baseDc) => isClean && (this.dcID !== baseDc || this.upload || this.sleepAfter && this.sleepAfter < (0, _timeManager.tsNow)());

    this.checkLongPoll = _asyncToGenerator(function* () {
      var isClean = _this.cleanupSent();
      if (_this.checkLongPollCond()) return false;

      var baseDc = yield _this.storage.get('dc');
      if (_this.checkLongPollAfterDcCond(isClean, baseDc))
        // console.warn(dTime(), 'Send long-poll for DC is delayed', this.dcID, this.sleepAfter)
        return;
      return _this.longPoll.sendLongPool();
    });

    function* _ref3(event) {
      log(`Check connection`)(event);
      _mtprotoShared.smartTimeout.cancel(_this.checkConnectionPromise);

      var serializer = new _tl.Serialization({ mtproto: true }, _this.uid);
      var pingID = (0, _mathHelp.getRandomId)();

      serializer.storeMethod('ping', { ping_id: pingID });

      var pingMessage = new _netMessage.NetMessage(_this.uid, _this.generateSeqNo(true), serializer.getBytes());
      _this.emit('net-message', {
        type: 'mtp-call',
        msg_id: pingMessage.msg_id,
        message: pingMessage,
        method: 'ping',
        params: { ping_id: pingID },
        options: {}
      });
      var succ = false;

      try {
        var result = yield _this.sendEncryptedRequest(pingMessage, { timeout: 15000 });
        succ = true;
        _this.toggleOffline(false);
        log(`checkConnection, result`)(result);
      } catch (err) {
        log(`encrypted request fail`)(err);
      }
      if (succ) return;
      var delay = _this.checkConnectionPeriod * 1e3;
      log(`checkConnection, Delay`)(delay);
      _this.checkConnectionPromise = (0, _mtprotoShared.smartTimeout)(_this.checkConnection, delay);
      _this.checkConnectionPeriod = Math.min(60, _this.checkConnectionPeriod * 1.5);
    }

    this.checkConnection = (() => {
      var _ref2 = _asyncToGenerator(_ref3);

      return function (_x) {
        return _ref2.apply(this, arguments);
      };
    })();

    this.performSheduledRequest = () => {
      //TODO extract huge method
      // console.log(dTime(), 'sheduled', this.dcID, this.iii)
      if (this.offline || akStopped) {
        log(`Cancel sheduled`)(``);
        return _bluebird2.default.resolve(false);
      }
      delete this.nextReq;
      if (this.pendingAcks.length) {
        var ackMsgIDs = [];
        for (var _iterator = this.pendingAcks, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref4;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref4 = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref4 = _i.value;
          }

          var ack = _ref4;

          ackMsgIDs.push(ack);
        }log('acking messages')(ackMsgIDs);
        this.wrapMtpMessage({
          _: 'msgs_ack',
          msg_ids: ackMsgIDs
        }, {
          notContentRelated: true,
          noShedule: true
        }); //TODO WTF Why we make wrapped message and doesnt use it?
        // const res = await msg.deferred.promise
        // log(`AWAITED`, `ack`)(res)
      }

      this.performResend();

      var messages = [];
      var message = void 0;
      var messagesByteLen = 0;
      // const currentTime = tsNow()
      var lengthOverflow = false;
      var singlesCount = 0;
      var logGroup = log.group('perform sheduled request');
      for (var _iterator2 = this.state.pendingIterator(), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref5;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref5 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref5 = _i2.value;
        }

        var [_messageID, value] = _ref5;

        if (value && value < (0, _timeManager.tsNow)()) continue;
        this.state.deletePending(_messageID);
        if (!this.state.hasSent(_messageID)) continue;
        message = this.state.getSent(_messageID);
        logGroup('message')(message);
        logGroup('messageID, value')(_messageID, value);
        var messageByteLength = message.size() + 32;
        var cond1 = !message.notContentRelated && lengthOverflow;
        var cond2 = !message.notContentRelated && messagesByteLen + messageByteLength > 655360; // 640 Kb
        if (cond1) continue;
        if (cond2) {
          lengthOverflow = true;
          continue;
        }
        if (message.singleInRequest) {
          singlesCount++;
          if (singlesCount > 1) continue;
        }
        messages.push(message);
        messagesByteLen += messageByteLength;
      }
      logGroup('message, final')(message);
      logGroup('messages')(messages);
      messages.map(msg => this.emit('message-in', msg));

      if (!message) return _bluebird2.default.resolve(false);

      if (message.isAPI && !message.longPoll) {
        var serializer = new _tl.Serialization({ mtproto: true }, this.uid);
        var params = {
          max_delay: 1000,
          wait_after: 550,
          max_wait: 3000
        };
        serializer.storeMethod('http_wait', params);
        var netMessage = new _netMessage.NetMessage(this.uid, this.generateSeqNo(), serializer.getBytes());
        this.longPoll.writePollTime();
        this.emit('net-message', {
          type: 'mtp-call',
          msg_id: netMessage.msg_id,
          message: netMessage,
          method: 'http_wait',
          params,
          options: {}
        });
        messages.push(netMessage);
      }

      if (!messages.length) {
        // console.log('no sheduled messages')
        return _bluebird2.default.resolve();
      }

      var noResponseMsgs = [];

      if (messages.length > 1) {
        var container = new _tl.Serialization({ mtproto: true, startMaxLength: messagesByteLen + 64 }, this.uid);
        var contBox = container.writer;
        (0, _writer.writeInt)(contBox, 0x73f1f8dc, 'CONTAINER[id]');
        (0, _writer.writeInt)(contBox, messages.length, 'CONTAINER[count]');

        var {
          innerMessages,
          noResponseMessages
        } = (0, _performRequest.writeInnerMessage)({
          writer: contBox,
          messages
        });
        noResponseMsgs = noResponseMessages;

        message = new _netMessage.NetContainer(this.uid, this.generateSeqNo(true), container.getBytes(true), innerMessages);

        logGroup(`Container`)(innerMessages, noResponseMessages, message.msg_id, message.seq_no);
      } else {
        if (message.noResponse) noResponseMsgs.push(message.msg_id);
      }
      logGroup.groupEnd();
      this.state.addSent(message);

      this.pendingAcks = []; //TODO WTF,he just clear and forget them at all?!?
      if (lengthOverflow || singlesCount > 1) this.sheduleRequest();

      return this.requestPerformer(message, noResponseMsgs);
    };

    function* _ref7(message, options = {}) {
      var apiBytes = (0, _encryptedMessage.apiMessage)({
        ctx: new _tl.Serialization({ startMaxLength: message.body.length + 64 }, _this.uid).writer,
        serverSalt: _this.serverSalt,
        sessionID: _this.sessionID,
        message
      });

      var { encryptedBytes, msgKey } = yield (0, _encryptedMessage.encryptApiBytes)({
        bytes: apiBytes,
        authKey: _this.authKeyUint8
      });

      var request = new _tl.Serialization({ startMaxLength: encryptedBytes.byteLength + 256 }, _this.uid).writer;

      var mtBytes = (0, _encryptedMessage.mtMessage)({
        ctx: request,
        authKeyID: _this.authKeyID,
        msgKey,
        encryptedBytes
      });

      var url = _configProvider2.default.dcMap(_this.uid, _this.dcID);
      var requestOpts = Object.assign({ responseType: 'arraybuffer' }, options);

      try {
        var result = yield _http.httpClient.post(url, mtBytes, requestOpts);
        if (!result.data.byteLength) {
          var err = new _error.ErrorBadResponse(url, result);
          _this.emit('response-raw', err);
          return _bluebird2.default.reject(err);
        }
        _this.emit('response-raw', {
          data: result.data,
          status: result.status,
          statusText: result.statusText,
          message,
          options
        });
        return result;
      } catch (error) {
        var _err = new _error.ErrorBadRequest(url, error);
        _this.emit('response-raw', _err);
        return _bluebird2.default.reject(_err);
      }
    }

    this.sendEncryptedRequest = (() => {
      var _ref6 = _asyncToGenerator(_ref7);

      return function (_x2) {
        return _ref6.apply(this, arguments);
      };
    })();

    this.getMsgById = ({ req_msg_id }) => this.state.getSent(req_msg_id);

    this.processMessageAck = messageID => {
      var sentMessage = this.state.getSent(messageID);
      if (sentMessage && !sentMessage.acked) {
        delete sentMessage.body;
        sentMessage.acked = true;
        return true;
      }
      return false;
    };

    this.uid = uid;
    this.appConfig = appConfig;
    this.storage = storage;
    var emitter = _configProvider2.default.rootEmitter(this.uid);
    this.emit = emitter.emit;
    this.dcID = dc;
    this.iii = iii++;

    this.longPoll = new _longPoll2.default(this);

    this.authKey = authKey;
    this.authKeyUint8 = (0, _bin.convertToUint8Array)(authKey);
    this.authKeyBuffer = (0, _bin.convertToArrayBuffer)(authKey);
    this.authKeyID = (0, _bin.sha1BytesSync)(authKey).slice(-8);

    //$FlowIssue
    this.wrapApiCall = this.wrapApiCall.bind(this);

    // this.checkLongPollCond = this.checkLongPollCond.bind(this)
    this.serverSalt = serverSalt;

    this.upload = false; //options.fileUpload || options.fileDownload || false

    emitter.emit('new-networker', this);

    this.updateSession();

    setInterval(this.checkLongPoll, 10000); //NOTE make configurable interval
    this.checkLongPoll();
  }
  updateSession() {
    this.seqNo = 0;
    this.prevSessionID = this.sessionID;
    this.sessionID = new Array(8);
    (0, _secureRandom2.default)(this.sessionID);
  }

  updateSentMessage(sentMessageID) {
    if (!this.state.hasSent(sentMessageID)) return false;
    var sentMessage = this.state.getSent(sentMessageID);

    if (sentMessage instanceof _netMessage.NetContainer) {
      var newInner = [];
      for (var _iterator3 = sentMessage.inner, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
        var _ref8;

        if (_isArray3) {
          if (_i3 >= _iterator3.length) break;
          _ref8 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done) break;
          _ref8 = _i3.value;
        }

        var innerID = _ref8;

        var innerSentMessage = this.updateSentMessage(innerID);
        if (innerSentMessage) newInner.push(innerSentMessage.msg_id);
      }
      sentMessage.inner = newInner;
    }
    this.state.deleteSent(sentMessage);
    var newId = (0, _timeManager.generateID)(this.uid);
    sentMessage.msg_id = newId;
    sentMessage.seq_no = this.generateSeqNo(sentMessage.notContentRelated || sentMessage.container);
    this.state.addSent(sentMessage);

    return sentMessage;
  }

  generateSeqNo(notContentRelated) {
    var seqNo = this.seqNo * 2;

    if (!notContentRelated) {
      seqNo++;
      this.seqNo++;
    }

    return seqNo;
  }

  wrapMtpCall(method, params, options) {
    var serializer = new _tl.Serialization({ mtproto: true }, this.uid);

    serializer.storeMethod(method, params);
    var seqNo = this.generateSeqNo();
    var message = new _netMessage.NetMessage(this.uid, seqNo, serializer.getBytes(true));
    this.emit('net-message', {
      type: 'mtp-call',
      msg_id: message.msg_id,
      message,
      method,
      params,
      options
    });
    log(`Call method`, `msg_id`, `seqNo`)(method, message.msg_id, seqNo);
    log(`Call method`, `params`)(params);

    this.pushMessage(message, options);
    return message.deferred.promise;
  }

  wrapMtpMessage(object, options = {}) {

    var serializer = new _tl.Serialization({ mtproto: true }, this.uid);
    serializer.storeObject(object, 'Object', 'wrap_message');

    var seqNo = this.generateSeqNo(options.notContentRelated);
    var message = new _netMessage.NetMessage(this.uid, seqNo, serializer.getBytes(true));
    this.emit('net-message', {
      type: 'mtp-message',
      msg_id: message.msg_id,
      message,
      object,
      options
    });
    log(`MT message`, `msg_id`, `seqNo`)(message.msg_id, seqNo);
    log(`MT message`, `result`)(object);
    verifyInnerMessages(object.msg_ids);
    this.pushMessage(message, options);
    return message;
  }

  wrapApiCall(method, params = {}, options) {
    var serializer = new _tl.Serialization(options, this.uid);
    var serialBox = serializer.writer;
    if (!this.connectionInited) {
      // serializer.storeInt(0xda9b0d0d, 'invokeWithLayer')
      // serializer.storeInt(Config.Schema.API.layer, 'layer')
      // serializer.storeInt(0x69796de9, 'initConnection')
      // serializer.storeInt(Config.App.id, 'api_id')
      // serializer.storeString(navigator.userAgent || 'Unknown UserAgent', 'device_model')
      // serializer.storeString(navigator.platform || 'Unknown Platform', 'system_version')
      // serializer.storeString(Config.App.version, 'app_version')
      // serializer.storeString(navigator.language || 'en', 'lang_code')
      var mapper = storeIntString(serialBox);
      (0, _ramda.mapObjIndexed)(mapper, this.appConfig);
    }

    if (options.afterMessageID) {
      (0, _writer.writeInt)(serialBox, 0xcb9f372d, 'invokeAfterMsg');
      (0, _writer.writeLong)(serialBox, options.afterMessageID, 'msg_id');
    }

    options.resultType = serializer.storeMethod(method, params);

    var seqNo = this.generateSeqNo();
    var message = new _netMessage.NetMessage(this.uid, seqNo, serializer.getBytes(true));
    message.isAPI = true;

    this.emit('net-message', {
      type: 'api-call',
      msg_id: message.msg_id,
      message,
      method,
      params,
      options
    });
    log(`Api call`)(method);
    log(`|      |`, `msg_id`, `seqNo`)(message.msg_id, seqNo);
    log(`|      |`, `params`)(params);
    log(`|      |`, `options`)(options);
    this.pushMessage(message, options);
    return message.deferred.promise;
  }

  pushMessage(message, options = {}) {
    message.copyOptions(options);
    this.emit('push-message', {
      threadID: this.threadID,
      message,
      options
    });
    this.state.addSent(message);
    this.state.setPending(message.msg_id);

    if (!options.noShedule) this.sheduleRequest();
    if ((0, _ramda.is)(Object, options)) options.messageID = message.msg_id;
  }

  pushResend(messageID, delay = 0) {
    var value = (0, _timeManager.tsNow)() + delay;
    var sentMessage = this.state.getSent(messageID);
    if (sentMessage instanceof _netMessage.NetContainer) {
      for (var _iterator4 = sentMessage.inner, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
        var _ref9;

        if (_isArray4) {
          if (_i4 >= _iterator4.length) break;
          _ref9 = _iterator4[_i4++];
        } else {
          _i4 = _iterator4.next();
          if (_i4.done) break;
          _ref9 = _i4.value;
        }

        var _msg = _ref9;

        this.state.setPending(_msg, value);
      }
    } else this.state.setPending(messageID, value);

    this.sheduleRequest(delay);
  }

  toggleOffline(enabled) {
    // console.log('toggle ', enabled, this.dcID, this.iii)
    if (!this.offline !== undefined && this.offline == enabled) return false;

    this.offline = enabled;

    if (this.offline) {
      _mtprotoShared.smartTimeout.cancel(this.nextReqPromise);
      delete this.nextReq;

      if (this.checkConnectionPeriod < 1.5) this.checkConnectionPeriod = 0;

      this.checkConnectionPromise = (0, _mtprotoShared.smartTimeout)(this.checkConnection, parseInt(this.checkConnectionPeriod * 1000));
      this.checkConnectionPeriod = Math.min(30, (1 + this.checkConnectionPeriod) * 1.5);

      this.onOnlineCb = this.checkConnection;
      this.emit('net.offline', this.onOnlineCb);
    } else {
      this.longPoll.pendingTime = Date.now();
      //NOTE check long state was here
      this.checkLongPoll().then(_ref10);
      this.sheduleRequest();

      if (this.onOnlineCb) this.emit('net.online', this.onOnlineCb);

      _mtprotoShared.smartTimeout.cancel(this.checkConnectionPromise);
    }
  }
  performResend() {
    if (this.state.hasResends()) {
      var resendMsgIDs = [...this.state.getResends()];
      var resendOpts = { noShedule: true, notContentRelated: true };
      // console.log('resendReq messages', resendMsgIDs)
      var msg = this.wrapMtpMessage({
        _: 'msg_resend_req',
        msg_ids: resendMsgIDs
      }, resendOpts);
      this.lastResendReq = { req_msg_id: msg.msg_id, resend_msg_ids: resendMsgIDs };
    }
  }


  requestPerformer(message, noResponseMsgs) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      try {
        var result = yield _this2.sendEncryptedRequest(message);
        _this2.toggleOffline(false);
        var response = yield _this2.parseResponse(result.data);
        log(`Server response`, `dc${_this2.dcID}`)(response);
        log(`message`)(message);

        yield _this2.processMessage(response.response, response.messageID, response.sessionID);

        for (var _iterator5 = noResponseMsgs, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
          var _ref11;

          if (_isArray5) {
            if (_i5 >= _iterator5.length) break;
            _ref11 = _iterator5[_i5++];
          } else {
            _i5 = _iterator5.next();
            if (_i5.done) break;
            _ref11 = _i5.value;
          }

          var msgID = _ref11;

          if (_this2.state.hasSent(msgID)) {
            var msg = _this2.state.getSent(msgID);
            _this2.state.deleteSent(msg);
            msg.deferred.resolve();
          }
        }_this2.checkConnectionPeriod = Math.max(1.1, Math.sqrt(_this2.checkConnectionPeriod));

        //return
        _this2.checkLongPoll(); //TODO Bluebird warning here
      } catch (error) {
        console.log('Encrypted request failed', error);

        if (message instanceof _netMessage.NetContainer) {
          for (var _iterator6 = message.inner, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
            var _ref12;

            if (_isArray6) {
              if (_i6 >= _iterator6.length) break;
              _ref12 = _iterator6[_i6++];
            } else {
              _i6 = _iterator6.next();
              if (_i6.done) break;
              _ref12 = _i6.value;
            }

            var _msgID = _ref12;

            _this2.state.setPending(_msgID);
          }_this2.state.deleteSent(message);
        } else _this2.state.setPending(message.msg_id);

        for (var _iterator7 = noResponseMsgs, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {
          var _ref13;

          if (_isArray7) {
            if (_i7 >= _iterator7.length) break;
            _ref13 = _iterator7[_i7++];
          } else {
            _i7 = _iterator7.next();
            if (_i7.done) break;
            _ref13 = _i7.value;
          }

          var _msgID2 = _ref13;

          if (_this2.state.hasSent(_msgID2)) {
            var _msg2 = _this2.state.getSent(_msgID2);
            _this2.state.deleteSent(_msg2);
            _this2.state.deletePending(_msgID2);
            _msg2.deferred.reject();
          }
        }_this2.toggleOffline(true);
        return _bluebird2.default.reject(error);
      }
    })();
  }

  parseResponse(responseBuffer) {
    var _this3 = this;

    return _asyncToGenerator(function* () {

      var { msgKey, encryptedData } = (0, _parseResponse.readResponse)({
        reader: new _tl.Deserialization(responseBuffer, {}, _this3.uid),
        response: responseBuffer,
        authKeyStored: _this3.authKeyID
      });

      var dataWithPadding = yield (0, _parseResponse.getDataWithPad)({
        authKey: _this3.authKeyUint8,
        msgKey,
        encryptedData
      });

      var {
        hashData,
        seqNo,
        messageID,
        buffer,
        sessionID
      } = (0, _parseResponse.readHash)({
        reader: new _tl.Deserialization(dataWithPadding, { mtproto: true }, _this3.uid),
        currentSession: _this3.sessionID,
        prevSession: _this3.prevSessionID,
        dataWithPadding
      });

      var deserializerOptions = {
        mtproto: true,
        getter: _this3.getMsgById
      };
      var response = yield (0, _parseResponse.parsedResponse)({
        hashData,
        msgKey,
        reader: new _tl.Deserialization(buffer, deserializerOptions, _this3.uid)
      });

      return {
        response,
        messageID,
        sessionID,
        seqNo
      };
    })();
  }

  applyServerSalt(newServerSalt) {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      var serverSalt = (0, _bin.longToBytes)(newServerSalt);
      yield _this4.storage.set(`dc${_this4.dcID}_server_salt`, (0, _bin.bytesToHex)(serverSalt));

      _this4.serverSalt = serverSalt;
      return true;
    })();
  }

  sheduleRequest(delay = 0) {
    if (this.offline) this.checkConnection('forced shedule');
    var nextReq = (0, _timeManager.tsNow)() + delay;

    if (delay && this.nextReq && this.nextReq <= nextReq) return false;

    // console.log(dTime(), 'shedule req', delay)
    // console.trace()
    _mtprotoShared.smartTimeout.cancel(this.nextReqPromise);
    if (delay > 0) this.nextReqPromise = (0, _mtprotoShared.smartTimeout)(this.performSheduledRequest, delay);else (0, _mtprotoShared.immediate)(this.performSheduledRequest);

    this.nextReq = nextReq;
  }

  ackMessage(msgID) {
    /*console.trace(msgID)
    if (this.pendingAcks.includes(msgID)) {
      debugger
    }*/
    // console.log('ack message', msgID)
    if ((0, _ramda.contains)(msgID, this.pendingAcks)) return;
    this.pendingAcks.push(msgID);
    this.sheduleRequest(30000);
  }

  reqResendMessage(msgID) {
    log(`Req resend`)(msgID);
    this.state.addResend(msgID);
    this.sheduleRequest(100);
  }

  cleanupSent() {
    var notEmpty = false;
    // console.log('clean start', this.dcID/*, this.state.sent*/)

    for (var _iterator8 = this.state.sentIterator(), _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator]();;) {
      var _ref14;

      if (_isArray8) {
        if (_i8 >= _iterator8.length) break;
        _ref14 = _iterator8[_i8++];
      } else {
        _i8 = _iterator8.next();
        if (_i8.done) break;
        _ref14 = _i8.value;
      }

      var [msgID, message] = _ref14;

      var complete = true;
      if (message.notContentRelated && !this.state.hasPending(msgID))
        // console.log('clean notContentRelated', msgID)
        this.state.deleteSent(message);else if (message instanceof _netMessage.NetContainer) {
        for (var _iterator9 = message.inner, _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator]();;) {
          var _ref15;

          if (_isArray9) {
            if (_i9 >= _iterator9.length) break;
            _ref15 = _iterator9[_i9++];
          } else {
            _i9 = _iterator9.next();
            if (_i9.done) break;
            _ref15 = _i9.value;
          }

          var inner = _ref15;

          if (this.state.hasSent(inner)) {
            // console.log('clean failed, found', msgID, message.inner[i],
            // this.state.getSent(message.inner[i]).seq_no)
            notEmpty = true;
            complete = false;
            break;
          }
        }
        // console.log('clean container', msgID)
        if (complete) this.state.deleteSent(message);
      } else notEmpty = true;
    }
    return !notEmpty;
  }

  processMessage(message, messageID, sessionID) {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      if (!isFinite(messageID)) {
        throw new TypeError(`Message ID should be finite ${messageID} ${typeof messageID}`);
      }
      var msgidInt = parseInt(messageID, 10);
      if (msgidInt % 2) {
        console.warn('[MT] Server even message id: ', messageID, message);
        return;
      }
      _this5.emit('incoming-message', {
        threadID: _this5.threadID,
        message,
        messageID,
        sessionID
      });
      switch (message._) {
        case 'msg_container':
          {
            for (var _iterator10 = message.messages, _isArray10 = Array.isArray(_iterator10), _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator]();;) {
              var _ref16;

              if (_isArray10) {
                if (_i10 >= _iterator10.length) break;
                _ref16 = _iterator10[_i10++];
              } else {
                _i10 = _iterator10.next();
                if (_i10.done) break;
                _ref16 = _i10.value;
              }

              var inner = _ref16;

              yield _this5.processMessage(inner, inner.msg_id, sessionID);
            }break;
          }
        case 'bad_server_salt':
          {
            log(`Bad server salt`)(message);
            var sentMessage = _this5.state.getSent(message.bad_msg_id);
            if (!sentMessage || sentMessage.seq_no != message.bad_msg_seqno) {
              log(`invalid message`)(message.bad_msg_id, message.bad_msg_seqno);
              throw new Error('[MT] Bad server salt for invalid message');
            }

            yield _this5.applyServerSalt(message.new_server_salt);
            _this5.pushResend(message.bad_msg_id);
            _this5.ackMessage(messageID);
            break;
          }
        case 'bad_msg_notification':
          {
            log(`Bad msg notification`)(message);
            var _sentMessage = _this5.state.getSent(message.bad_msg_id);
            if (!_sentMessage || _sentMessage.seq_no != message.bad_msg_seqno) {
              log(`invalid message`)(message.bad_msg_id, message.bad_msg_seqno);
              throw new Error('[MT] Bad msg notification for invalid message');
            }

            if (message.error_code == 16 || message.error_code == 17) {
              if ((0, _timeManager.applyServerTime)(_this5.uid, (0, _bin.rshift32)(messageID))) {
                log(`Update session`)();
                _this5.updateSession();
              }
              var badMessage = _this5.updateSentMessage(message.bad_msg_id);
              if (badMessage instanceof _netMessage.NetMessage) _this5.pushResend(badMessage.msg_id);
              _this5.ackMessage(messageID);
            }
            break;
          }
        case 'message':
          {
            if (_this5.lastServerMessages.indexOf(messageID) != -1) {
              // console.warn('[MT] Server same messageID: ', messageID)
              _this5.ackMessage(messageID);
              return;
            }
            _this5.lastServerMessages.push(messageID);
            if (_this5.lastServerMessages.length > 100) {
              _this5.lastServerMessages.shift();
            }
            yield _this5.processMessage(message.body, message.msg_id, sessionID);
            break;
          }
        case 'new_session_created':
          {
            // this.ackMessage(messageID)

            // this.processMessageAck(message.first_msg_id)
            // await this.applyServerSalt(message.server_salt)

            _this5.emit('new-session', {
              threadID: _this5.threadID,
              networkerDC: _this5.dcID,
              messageID,
              message
            });

            // const baseDcID = await this.storage.get('dc')
            // const updateCond =
            //   baseDcID === this.dcID &&
            //   !this.upload &&
            //   updatesProcessor
            // if (updateCond)
            //   updatesProcessor(message, true)

            break;
          }
        case 'msgs_ack':
          {
            message.msg_ids.forEach(_this5.processMessageAck);
            break;
          }
        case 'msg_detailed_info':
          {
            if (!_this5.state.hasSent(message.msg_id)) {
              _this5.ackMessage(message.answer_msg_id);
              break;
            }
            break;
          }
        case 'msg_new_detailed_info':
          {
            _this5.ackMessage(message.answer_msg_id);
            _this5.reqResendMessage(message.answer_msg_id);
            break;
          }
        case 'msgs_state_info':
          {
            _this5.ackMessage(message.answer_msg_id);
            var spliceCond = _this5.lastResendReq &&
            //eslint-disable-next-line
            _this5.lastResendReq.req_msg_id == message.req_msg_id;
            if (spliceCond) {
              for (var _iterator11 = _this5.lastResendReq.resend_msg_ids, _isArray11 = Array.isArray(_iterator11), _i11 = 0, _iterator11 = _isArray11 ? _iterator11 : _iterator11[Symbol.iterator]();;) {
                var _ref17;

                if (_isArray11) {
                  if (_i11 >= _iterator11.length) break;
                  _ref17 = _iterator11[_i11++];
                } else {
                  _i11 = _iterator11.next();
                  if (_i11.done) break;
                  _ref17 = _i11.value;
                }

                var _badMsgID = _ref17;

                _this5.state.deleteResent(_badMsgID);
              }
            }break;
          }
        case 'rpc_result':
          {
            _this5.ackMessage(messageID);

            var sentMessageID = message.req_msg_id;
            var _sentMessage2 = _this5.state.getSent(sentMessageID);

            _this5.processMessageAck(sentMessageID);
            if (!_sentMessage2) break;

            if (message.result._ == 'rpc_error') {
              _this5.emit('rpc-error', {
                threadID: _this5.threadID,
                networkerDC: _this5.dcID,
                error: message.result,
                sentMessage: _sentMessage2,
                message
              });
            } else {
              _this5.emit('rpc-result', {
                threadID: _this5.threadID,
                networkerDC: _this5.dcID,
                message,
                sentMessage: _sentMessage2,
                result: message.result
              });
              if (_sentMessage2.isAPI) _this5.connectionInited = true;
            }
            _this5.state.deleteSent(_sentMessage2);
            break;
          }
        default:
          {
            _this5.ackMessage(messageID);
            _this5.emit('untyped-message', {
              threadID: _this5.threadID,
              networkerDC: _this5.dcID,
              message,
              messageID,
              sessionID,
              result: message.result
            });
            if (updatesProcessor) updatesProcessor(message, true);
            break;
          }
      }
    })();
  }
}

exports.NetworkerThread = NetworkerThread;
var startAll = exports.startAll = () => {
  if (akStopped) {
    akStopped = false;
    updatesProcessor({ _: 'new_session_created' }, true);
  }
};

var stopAll = exports.stopAll = () => akStopped = true;

var setUpdatesProcessor = exports.setUpdatesProcessor = callback => updatesProcessor = callback;

var verifyInnerMessages = messages => {
  if (messages.length !== new Set(messages).size) {
    console.log(`!!!!!!WARN!!!!!!`, 'container check failed', messages);
    // throw new Error('Container bug')
  }
};

exports.default = NetworkerThread;
//# sourceMappingURL=index.js.map