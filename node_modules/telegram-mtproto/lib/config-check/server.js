'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkFullServerConfig = exports.validatorList = undefined;

var _Either = require('flow-static-land/lib/Either');

var either = _interopRequireWildcard(_Either);

var _errorList = require('./error-list');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// import type { Monad } from 'flow-static-land/src/Monad'
// import type { Tuple, TupleV } from 'flow-static-land/src/Tuple'
// import type { Pointed } from 'flow-static-land/src/Pointed'
function _ref(list) {
  return either.left(list);
}
// import { HKT } from 'flow-static-land/lib/HKT'
// import * as tuple from 'flow-static-land/lib/Tuple'

// import Reader from 'fantasy-readers'

// import { traverse } from 'ramda'

var doCata = (pair, obj) => pair.second().cata({
  Empty: () => either.of(obj),
  List: _ref
});

var makeErrorCheck = check => obj => check.test(obj) ? _errorList.ValidationPair.empty(obj) : _errorList.ValidationPair.of(obj, check.error(obj));

// const makeRightCheck = (check: ErrorChecker) =>
//   (eitherConfig: Either<Config, Config>): ValidationPair => {
//     either.isRight(eitherConfig)
//       ?
//       :
//     either.chain(
//       (obj: Config): ValidationPair =>
//         check.test(obj)
//           ? ValidationPair.empty(either.of(obj))
//           : ValidationPair.of(
//             either.left(obj),
//             check.error(obj)
//           ),
//       eitherConfig
//     )
//   }

var validatorList = exports.validatorList = _errorList.Validator.of([{
  test: config => typeof config.path === 'string',
  error: config => `type of path should be string, get ${typeof config.path}`
}, {
  test: config => typeof config.protocol === 'string',
  error: config => `type of protocol should be string, get ${typeof config.protocol}`
}, {
  test: config => typeof config.port === 'number',
  error: config => `type of port should be number, get ${typeof config.port}`
}, {
  test: config => Array.isArray(config.dcList),
  error: config => `type of dcList should be array, get ${typeof config.dcList}`
}]);

var checkReduce = (acc, checker) => acc.chain(makeErrorCheck(checker));

// const checkReduceStrict =
//   (acc: ValidationPair, checker: ErrorChecker) => acc.chain(makeRightCheck(checker))

var doValidate = validator => obj => {
  var state = _errorList.ValidationPair.empty(obj);
  var result = validator.reduce(checkReduce, state);
  return doCata(result, obj);
};

// const doValidateSeq = (validator: Validator) =>
//   (obj: Config): ValidatedConfig => {
//     const state = ValidationPair.empty(either.of(obj))
//     const result = validator.reduce(checkReduceStrict, state)
//     return doCata(result, obj)
//   }

var validate = doValidate(validatorList);

var checkFullServerConfig = exports.checkFullServerConfig = validate;

exports.default = validate;
//# sourceMappingURL=server.js.map