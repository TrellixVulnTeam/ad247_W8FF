//@flow

// import { tagged } from 'daggy'

// const PairFunctor = tagged('PairFunctor', ['$1', '$2'])

// // We just transform the second value!
// // map :: PairFunctor a b ~> (b -> c) -> PairFunctor a c
// PairFunctor.prototype.map = function(f) {
//   return PairFunctor(this.$1, f(this.$2))
// }

interface Semigroup<T> {
  concat(obj: Semigroup<T>): $Subtype<Semigroup<T>>
}

interface Monoid<T> extends Semigroup<T> {
  static empty(): $Subtype<Monoid<T>>
}

interface PairObj<E, A: $Subtype<Monoid<T>>, B> {
  $1: A,
  $2: B,
  map<D>(f: (obj: B) => D): PairObj<E, A, D>,
  ap<D>(fs: PairObj<E, A, (obj: B) => D>): PairObj<E, A, D>,
  chain<D>(f: (obj: B) => PairObj<E, A, D>): PairObj<E, A, D>,
  static of<D>(x: D): PairObj<E, A, D>,
  // new ($1: A, $2: B): PairObj<E, A, B>,
}

// const daggyPair = tagged('Pair$', ['$1', '$2'])

// const Pair = <E, T: Monoid<E>>(T$: Class<T>) =>

class List<T> extends Array<T> implements Monoid<T>, Semigroup<T> {
  // lst: Array<T> & $Subtype<Semigroup<T>>
  // constructor(lst: Array<T>) {
  //   this.lst = lst
  // }
  static empty(): $Subtype<Monoid<T>> {
    const lst: Array<T> & $Subtype<Semigroup<T>> = []
    return new List(0)
  }
  // static get [Symbol.species]() { return List }
  static of(lst: Array<T>) {
    return new List(lst)
  }
  constructor(lst: Array<T> | number) {
    if (typeof lst === 'number' || lst.length === 0) {
      super(lst)
    } else {
      super(...lst)
    }
  }
  // concat(list: $Subtype<Semigroup<T>>): $Subtype<Semigroup<T>> {
  //   if (list instanceof List) {
  //     const lst: $Subtype<Semigroup<T>> = new List(this.lst.concat(list.lst))
  //     return lst
  //   } else {
  //     return list.concat(this.lst)
  //   }
  // }
  // length(): number {
  //   return this.lst.length
  // }
  // map<S>(fn: (obj: T) => S): List<S> {
  //   return new List(this.lst.map(fn))
  // }
  // filter(fn: (obj: T) => boolean): List<T> {
  //   return new List(this.lst.filter(fn))
  // }
}

type User = {
  id: number,
  hair: string,
  height: number
}

class Pair<E, T: List<E>, B> implements PairObj<E, T, B> {
  $1: T
  $2: B
  constructor($1: T, $2: B) {
    this.$1 = $1
    this.$2 = $2
  }
  map<D>(f: (obj: B) => D): PairObj<E, T, D> {
    const new$2 = f(this.$2)
    return new Pair(this.$1, new$2)
  }
  ap<D>(fs: PairObj<E, T, (obj: B) => D>): PairObj<E, T, D>{
    const new$2 = fs.$2(this.$2)
    return new Pair(fs.$1.concat(this.$1), new$2)
  }
  chain<D>(f: (obj: B) => PairObj<E, T, D>): PairObj<E, T, D> {
    const that: PairObj<E, T, D> = f(this.$2)

    return new Pair(this.$1.concat(that.$1),
                that.$2)
  }
  static of(x: B): PairObj<E, T, B>{
    return new Pair(List.empty(), x)
  }
}

const users: Array<User> = [
  {
    id: 1,
    hair: 'brown',
    height: 185
  }, {
    id: 2,
    hair: 'blonde',
    height: 165
  }, {
    id: 3,
    hair: 'blonde',
    height: 181
  }, {
    id: 4,
    hair: 'brown',
    height: 175
  }, {
    id: 5,
    hair: 'blonde',
    height: 187
  },
]

export const result =
  Pair
    .of(List.of(users))
    .chain(
      users => new Pair(
        ['Blonde hair'],
        users.filter(
          user => user.hair === 'blonde')))

  // Keep only the users over 180cm tall
    .chain(
      users => new Pair(
        ['Tall'],
        users.filter(
          user => user.height > 180)))

    // Count the remaining users
    // .map(users => users.length)
/*{
  const Pair$: Pair$Type = tagged('Pair$', ['$1', '$2'])

  Pair$.prototype.map = function(f) {
    return Pair$(this.$1, f(this.$2))
  }

  Pair$.prototype.ap = function(fs) {
    return Pair$(fs.$1.concat(this.$1),
                 fs.$2(this.$2))
  }

  Pair$.of = x => Pair$(T.empty(), x)

  Pair$.prototype.chain = function(f) {
    const that = f(this.$2)

    return Pair$(this.$1.concat(that.$1),
                 that.$2)
  }

  return Pair$
}*/

// const PairList = Pair(List)

export default Pair
