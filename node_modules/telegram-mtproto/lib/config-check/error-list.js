'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Validator = exports.ValidationPair = exports.ErrorSet = undefined;

var _Tuple = require('flow-static-land/lib/Tuple');

var tuple = _interopRequireWildcard(_Tuple);

var _Arr = require('flow-static-land/lib/Arr');

var arr = _interopRequireWildcard(_Arr);

var _Either = require('flow-static-land/lib/Either');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

class ErrorSet {
  constructor(list) {
    this.list = list;
  }
  static of(str) {
    var injected = arr.of(str);
    return new ErrorSet(injected);
  }
  static empty() {
    var injected = arr.empty();
    return new ErrorSet(injected);
  }
  isEmpty() {
    return arr.isEmpty(this.list);
  }
  append(error) {
    var injected = arr.snoc(this.list, error);
    return new ErrorSet(injected);
  }
  concat(y) {
    var injected = arr.concat(this.list, y.list);
    return new ErrorSet(injected);
  }
  cata(opts) {
    if (this.isEmpty()) {
      return opts.Empty(this.list);
    }
    return opts.List(this.list);
  }
}

exports.ErrorSet = ErrorSet;

// import type { Arr } from 'flow-static-land/src/Arr'
// import type { Tuple, TupleV } from 'flow-static-land/src/Tuple'

class ValidationPair {
  constructor(pair) {
    this.pair = pair;
  }
  static of(obj, str) {
    var pair = [obj, ErrorSet.of(str)];
    var injected = tuple.inj(pair);
    return new ValidationPair(injected);
  }
  static empty(obj) {
    var pair = [obj, ErrorSet.empty()];
    var injected = tuple.inj(pair);
    return new ValidationPair(injected);
  }
  first() {
    return tuple.fst(this.pair);
  }
  second() {
    return tuple.snd(this.pair);
  }
  map(f) {
    var injected = tuple.map(f, this.pair);
    return new ValidationPair(injected);
  }
  concat(y) {
    var f = a => this.second().concat(a);
    return y.map(f);
  }
  chain(f) {
    var newPair = f(this.first());
    return this.concat(newPair);
  }
}

exports.ValidationPair = ValidationPair;
class Validator {
  constructor(list) {
    this.list = list;
  }
  static of(list) {
    var injected = arr.inj(list);
    return new Validator(injected);
  }
  static empty() {
    return Validator.of([]);
  }
  concat(y) {
    var injected = arr.concat(this.list, y.list);
    return new Validator(injected);
  }
  reduce(f, pair) {
    return arr.reduce(f, pair, this.list);
  }
}
exports.Validator = Validator;
//# sourceMappingURL=error-list.js.map