//@flow

// import { traverse } from 'ramda'

import type { Either } from 'flow-static-land/src/Either'
// import type { Monad } from 'flow-static-land/src/Monad'
// import type { Tuple, TupleV } from 'flow-static-land/src/Tuple'
// import type { Pointed } from 'flow-static-land/src/Pointed'
import * as either from 'flow-static-land/lib/Either'
// import { HKT } from 'flow-static-land/lib/HKT'
// import * as tuple from 'flow-static-land/lib/Tuple'

// import Reader from 'fantasy-readers'

import type { Config, ConfigError, ErrorChecker, ConfigCheck } from './index.h'

import { ErrorSet, Validator, ValidationPair } from './error-list'

type ValidatedConfig = Either<ConfigError, Config>

const doCata = (pair: ValidationPair, obj: Config) => pair.second().cata({
  Empty: (): ValidatedConfig => either.of(obj),
  List : (list: ConfigError): ValidatedConfig => either.left(list)
})

const makeErrorCheck =
  (check: ErrorChecker) =>
    (obj: Config): ValidationPair =>
      check.test(obj)
        ? ValidationPair.empty(obj)
        : ValidationPair.of(obj, check.error(obj))

// const makeRightCheck = (check: ErrorChecker) =>
//   (eitherConfig: Either<Config, Config>): ValidationPair => {
//     either.isRight(eitherConfig)
//       ?
//       :
//     either.chain(
//       (obj: Config): ValidationPair =>
//         check.test(obj)
//           ? ValidationPair.empty(either.of(obj))
//           : ValidationPair.of(
//             either.left(obj),
//             check.error(obj)
//           ),
//       eitherConfig
//     )
//   }

export const validatorList = Validator.of([
  {
    test : (config: Config) => typeof config.path === 'string',
    error: (config: Config) => `type of path should be string, get ${typeof config.path}`
  },
  {
    test : (config: Config) => typeof config.protocol === 'string',
    error: (config: Config) => `type of protocol should be string, get ${typeof config.protocol}`
  },
  {
    test : (config: Config) => typeof config.port === 'number',
    error: (config: Config) => `type of port should be number, get ${typeof config.port}`
  },
  {
    test : (config: Config) => Array.isArray(config.dcList),
    error: (config: Config) => `type of dcList should be array, get ${typeof config.dcList}`
  },
])

const checkReduce =
  (acc: ValidationPair, checker: ErrorChecker) => acc.chain(makeErrorCheck(checker))

// const checkReduceStrict =
//   (acc: ValidationPair, checker: ErrorChecker) => acc.chain(makeRightCheck(checker))

const doValidate = (validator: Validator) =>
  (obj: Config): ValidatedConfig => {
    const state = ValidationPair.empty(obj)
    const result = validator.reduce(checkReduce, state)
    return doCata(result, obj)
  }

// const doValidateSeq = (validator: Validator) =>
//   (obj: Config): ValidatedConfig => {
//     const state = ValidationPair.empty(either.of(obj))
//     const result = validator.reduce(checkReduceStrict, state)
//     return doCata(result, obj)
//   }

const validate = doValidate(validatorList)

export const checkFullServerConfig = validate

export default validate
