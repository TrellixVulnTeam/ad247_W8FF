//@flow

// import type { Arr } from 'flow-static-land/src/Arr'
// import type { Tuple, TupleV } from 'flow-static-land/src/Tuple'

import * as tuple from 'flow-static-land/lib/Tuple'
import * as arr from 'flow-static-land/lib/Arr'
import { isLeft, fromLeft } from 'flow-static-land/lib/Either'

import type { Tuple } from 'flow-static-land/src/Tuple'

import type { ConfigError, ErrorChecker, ConfigCheck, Config } from './index.h'

interface ErrorCases<-R, -L> {
  List(list: ConfigError): R,
  Empty(list: ConfigError): L,
}

type StateTuple = Tuple<Config, ConfigCheck>

export class ErrorSet {
  list: ConfigError
  constructor(list: ConfigError) {
    this.list = list
  }
  static of(str: string) {
    const injected = arr.of(str)
    return new ErrorSet(injected)
  }
  static empty() {
    const injected = arr.empty()
    return new ErrorSet(injected)
  }
  isEmpty(): boolean {
    return arr.isEmpty(this.list)
  }
  append(error: string) {
    const injected = arr.snoc(this.list, error)
    return new ErrorSet(injected)
  }
  concat(y: ErrorSet) {
    const injected = arr.concat(this.list, y.list)
    return new ErrorSet(injected)
  }
  cata<-R, -L>(opts: ErrorCases<R, L>): R | L {
    if (this.isEmpty()) {
      return opts.Empty(this.list)
    }
    return opts.List(this.list)
  }
}

export class ValidationPair {
  pair: StateTuple
  constructor(pair: StateTuple) {
    this.pair = pair
  }
  static of(obj: Config, str: string) {
    const pair = [obj, ErrorSet.of(str)]
    const injected = tuple.inj(pair)
    return new ValidationPair(injected)
  }
  static empty(obj: Config) {
    const pair = [obj, ErrorSet.empty()]
    const injected = tuple.inj(pair)
    return new ValidationPair(injected)
  }
  first(): Config {
    return tuple.fst(this.pair)
  }
  second(): ErrorSet {
    return tuple.snd(this.pair)
  }
  map(f: (a: ErrorSet) => ErrorSet) {
    const injected = tuple.map(f, this.pair)
    return new ValidationPair(injected)
  }
  concat(y: ValidationPair) {
    const f = (a: ErrorSet): ErrorSet =>
      this.second().concat(a)
    return y.map(f)
  }
  chain(f: (a: Config) => ValidationPair): ValidationPair {
    const newPair = f(this.first())
    return this.concat(newPair)
  }
}

export class Validator {
  list: ConfigCheck
  constructor(list: ConfigCheck) {
    this.list = list
  }
  static of(list: ErrorChecker[]) {
    const injected = arr.inj(list)
    return new Validator(injected)
  }
  static empty() {
    return Validator.of([])
  }
  concat(y: Validator) {
    const injected = arr.concat(this.list, y.list)
    return new Validator(injected)
  }
  reduce(
    f: (acc: ValidationPair, value: ErrorChecker) => ValidationPair,
    pair: ValidationPair
  ): ValidationPair {
    return arr.reduce(f, pair, this.list)
  }
}
