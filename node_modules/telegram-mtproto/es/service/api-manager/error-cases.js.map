{"version":3,"sources":["../../../src/service/api-manager/error-cases.js"],"names":["isNil","propOr","blueDefer","Switch","MTError","tsNow","cachedExportPromise","protect","code","NaN","type","rawError","dcID","baseDcID","base","errR","patterns","noBaseAuth","noDcAuth","waitFail","_","matchProtect","matched","error","options","emit","rejectPromise","requestThunk","apiSavedNet","apiRecall","deferResolve","mtpInvokeApi","storage","invoke","throwNext","reject","importAuth","id","bytes","noErrorBox","dc","exportDeferred","dc_id","then","resolve","catch","promise","now","stopTime","waitTime","Math","min","def","switchErrors"],"mappings":"AAEA,SAASA,KAAT,EAAgBC,MAAhB,QAA8B,OAA9B;;AAEA,OAAOC,SAAP,MAAsB,kBAAtB;AACA,OAAOC,MAAP,MAAmB,mBAAnB;AACA,SAASC,OAAT,QAAwB,aAAxB;AACA,SAASC,KAAT,QAAsB,iBAAtB;;AAEA,IAAMC,sBAAsB,EAA5B;;AAEA,IAAMC,UAAU,CACZ,EAAEC,OAAOC,GAAT,EAAcC,OAAO,EAArB,EADY,EAEZ,EAAEC,WAAW,IAAb,EAFY,EAGZC,IAHY,EAIZC,QAJY,MAKR;AACJC,QAAMD,QADF;AAEJE,QAAMJ,QAFF;AAGJH,MAHI;AAIJE,MAJI;AAKJE;AALI,CALQ,CAAhB;;AAqBA,IAAMI,WAAW;AACfC,cAAY,CAAC,EAAET,IAAF,EAAQI,IAAR,EAAcE,IAAd,EAAD,KACVN,SAAS,GAAT,IACAI,SAASE,IAHI;AAIfI,YAAU,CAAC,EAAEV,IAAF,EAAQI,IAAR,EAAcE,IAAd,EAAD,KACRN,SAAS,GAAT,IACAI,SAASE,IANI;AAOfK,YAAU,CAAC,EAAEX,IAAF,EAAQE,IAAR,EAAcK,IAAd,EAAD,KACR,CAACA,IAAD,KACEP,SAAS,GAAT,IACAE,SAAS,iBAFX,CARa;AAWfU,KAAU,MAA4B;AAXvB,CAAjB;;AAeA,IAAMC,eACHC,OAAD,IAAgB,CACZC,KADY,EAEZC,OAFY,EAGZZ,IAHY,EAIZa,IAJY,EAKZC,aALY,EAMZC,YANY,EAOZC,WAPY,EAQZC,SARY,EASZC,YATY,EAUZC,YAVY,EAWZC,OAXY,KAaZV,QAAQ;AACNW,UAAWF,YADL;AAENG,aAAW,MAAMR,cAAcH,KAAd,CAFX;AAGNY,UAAWT,aAHL;AAINF,SAJM;AAKNZ,MALM;AAMNa,MANM;AAONE,cAPM;AAQNE,WARM;AASNC,cATM;AAUNF,aAVM;AAWNI;AAXM,CAAR,CAdN;;AA6BA,IAAMf,aAAa,CAAC,EAAEQ,IAAF,EAAQS,SAAR,CAAiB,aAAjB,EAAD,KAAsC;AACvD;AACAT,OAAK,gBAAL;AACAS;AACD,CAJD;;AAMA,IAAMhB,WAAW,CAAC,EAAEN,IAAF,EAAQuB,MAAR,EAAgBP,WAAhB,EAA6BC,SAA7B,EAAwCC,YAAxC,EAAsDG,MAAtD,EAAD,KAAoE;AACnF,MAAMG,aAAa,CAAC,EAAEC,EAAF,EAAMC,KAAN,EAAD,KAAmBL,OACpC,0BADoC,EAEpC,EAAEI,EAAF,EAAMC,KAAN,EAFoC,EAGpC,EAAE1B,IAAF,EAAQ2B,YAAY,IAApB,EAA0BC,IAAI5B,IAA9B,EAHoC,CAAtC;;AAMA,MAAIZ,MAAMM,oBAAoBM,IAApB,CAAN,CAAJ,EAAsC;AACpC,QAAM6B,iBAAiBvC,WAAvB;;AAEA+B,WACE,0BADF,EAEE,EAAES,OAAO9B,IAAT,EAFF,EAGE,EAAE2B,YAAY,IAAd,EAHF,EAKGI,IALH,CAKQP,UALR,EAMGO,IANH,CAMQF,eAAeG,OANvB,EAOGC,KAPH,CAOSJ,eAAeN,MAPxB;;AASA7B,wBAAoBM,IAApB,IAA4B6B,eAAeK,OAA3C;AACD;;AAIDxC,sBAAoBM,IAApB,EAA0B;AAA1B,GACG+B,IADH,CACQf,WADR,EAEGe,IAFH,CAEQd,SAFR,EAGGc,IAHH,CAGQb,YAHR,EAIGe,KAJH,CAISV,MAJT;AAKD,CA7BD;AA8BA;;;;;;;;;;;;;;;;;AAiBA;;;;;;;AAOA,IAAMhB,WAAW,CAAC,EAAEK,OAAF,EAAWU,SAAX,EAAsBP,YAAtB,EAAD,KAA0C;AACzD,MAAMoB,MAAM1C,OAAZ;AACA,MAAImB,QAAQwB,QAAZ,EAAsB;AACpB,QAAID,OAAOvB,QAAQwB,QAAnB,EACE,OAAOd,WAAP;AACH,GAHD,MAIEV,QAAQwB,QAAR,GAAmBD,MAAM9C,OAAO,EAAP,EAAW,SAAX,EAAsBuB,OAAtB,IAAiC,IAA1D;AACFA,UAAQyB,QAAR,GAAmBzB,QAAQyB,QAAR,GACfC,KAAKC,GAAL,CAAS,EAAT,EAAa3B,QAAQyB,QAAR,GAAmB,GAAhC,CADe,GAEf,CAFJ;AAGAtB,eAAaH,QAAQyB,QAArB;AACD,CAXD;;AAaA,IAAMG,MAAM,CAAC,EAAElB,SAAF,EAAD,KAAmBA,WAA/B;;AAGA,OAAO,IAAMmB,eAAelD,OAAOa,QAAP,EAAiBT,OAAjB,EAA0B;AACpDU,YADoD;AAEpDC,UAFoD;AAGpDC,UAHoD;AAIpDC,KAAGgC;AAJiD,CAA1B,EAKzB/B,YALyB,CAArB","file":"error-cases.js","sourcesContent":["//@flow\n\nimport { isNil, propOr } from 'ramda'\n\nimport blueDefer from '../../util/defer'\nimport Switch from '../../util/switch'\nimport { MTError } from '../../error'\nimport { tsNow } from '../time-manager'\n\nconst cachedExportPromise = {}\n\nconst protect = (\n    { code = NaN, type = '' }: MTError,\n    { rawError = null }: { rawError: * },\n    dcID: number,\n    baseDcID: number\n  ) => ({\n    base: baseDcID,\n    errR: rawError,\n    code,\n    type,\n    dcID\n  })\n\ntype ProtectedProps = {\n  type: string,\n  code: number,\n  dcID: number,\n  base: number,\n  errR: *,\n}\n\nconst patterns = {\n  noBaseAuth: ({ code, dcID, base }: ProtectedProps)  =>\n    code === 401 &&\n    dcID === base,\n  noDcAuth: ({ code, dcID, base }: ProtectedProps)  =>\n    code === 401 &&\n    dcID !== base,\n  waitFail: ({ code, type, errR }: ProtectedProps)  =>\n    !errR && (\n      code === 500 ||\n      type === 'MSG_WAIT_FAILED'),\n  _       : ()                      =>  true\n}\n\n\nconst matchProtect =\n  (matched: *) => (\n      error: *,\n      options: *,\n      dcID: number,\n      emit: *,\n      rejectPromise: *,\n      requestThunk: *,\n      apiSavedNet: *,\n      apiRecall: *,\n      deferResolve: *,\n      mtpInvokeApi: *,\n      storage: *\n    ) =>\n      matched({\n        invoke   : mtpInvokeApi,\n        throwNext: () => rejectPromise(error),\n        reject   : rejectPromise,\n        options,\n        dcID,\n        emit,\n        requestThunk,\n        apiRecall,\n        deferResolve,\n        apiSavedNet,\n        storage\n      })\n\n\nconst noBaseAuth = ({ emit, throwNext/*, storage*/ }) => {\n  // storage.remove('dc', 'user_auth')\n  emit('error.401.base')\n  throwNext()\n}\n\nconst noDcAuth = ({ dcID, reject, apiSavedNet, apiRecall, deferResolve, invoke }) => {\n  const importAuth = ({ id, bytes }) => invoke(\n    'auth.importAuthorization',\n    { id, bytes },\n    { dcID, noErrorBox: true, dc: dcID })\n\n\n  if (isNil(cachedExportPromise[dcID])) {\n    const exportDeferred = blueDefer()\n\n    invoke(\n      'auth.exportAuthorization',\n      { dc_id: dcID },\n      { noErrorBox: true })\n\n      .then(importAuth)\n      .then(exportDeferred.resolve)\n      .catch(exportDeferred.reject)\n\n    cachedExportPromise[dcID] = exportDeferred.promise\n  }\n\n\n\n  cachedExportPromise[dcID] //TODO not returning promise\n    .then(apiSavedNet)\n    .then(apiRecall)\n    .then(deferResolve)\n    .catch(reject)\n}\n/*\nconst migrate = ({ error, dcID, options, reject,\n    apiRecall, deferResolve, getNet, storage\n  }) => {\n  const newDcID = error.type.match(/^(PHONE_MIGRATE_|NETWORK_MIGRATE_|USER_MIGRATE_)(\\d+)/)[2]\n  if (newDcID === dcID) return\n  if (options.dcID)\n    options.dcID = newDcID\n  else\n    storage.set('dc', newDcID)\n\n  getNet(newDcID, options)\n    .then(apiRecall)\n    .then(deferResolve)\n    .catch(reject)\n}*/\n\n/*const floodWait = ({ error, options, throwNext, requestThunk }) => {\n  const waitTime = error.type.match(/^FLOOD_WAIT_(\\d+)/)[1] || 10\n  if (waitTime > (options.timeout || 60))\n    return throwNext()\n  requestThunk(waitTime)\n}*/\n\nconst waitFail = ({ options, throwNext, requestThunk }) => {\n  const now = tsNow()\n  if (options.stopTime) {\n    if (now >= options.stopTime)\n      return throwNext()\n  } else\n    options.stopTime = now + propOr(10, 'timeout', options) * 1000\n  options.waitTime = options.waitTime\n    ? Math.min(60, options.waitTime * 1.5)\n    : 1\n  requestThunk(options.waitTime)\n}\n\nconst def = ({ throwNext }) => throwNext()\n\n\nexport const switchErrors = Switch(patterns, protect)({\n  noBaseAuth,\n  noDcAuth,\n  waitFail,\n  _: def\n}, matchProtect)"]}