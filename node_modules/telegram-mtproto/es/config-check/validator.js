

// const daggyPair = tagged('Pair$', ['$1', '$2'])

// const Pair = <E, T: Monoid<E>>(T$: Class<T>) =>

class List extends Array {
  // lst: Array<T> & $Subtype<Semigroup<T>>
  // constructor(lst: Array<T>) {
  //   this.lst = lst
  // }
  static empty() {
    var lst = [];
    return new List(0);
  }
  // static get [Symbol.species]() { return List }
  static of(lst) {
    return new List(lst);
  }
  constructor(lst) {
    if (typeof lst === 'number' || lst.length === 0) {
      super(lst);
    } else {
      super(...lst);
    }
  }
  // concat(list: $Subtype<Semigroup<T>>): $Subtype<Semigroup<T>> {
  //   if (list instanceof List) {
  //     const lst: $Subtype<Semigroup<T>> = new List(this.lst.concat(list.lst))
  //     return lst
  //   } else {
  //     return list.concat(this.lst)
  //   }
  // }
  // length(): number {
  //   return this.lst.length
  // }
  // map<S>(fn: (obj: T) => S): List<S> {
  //   return new List(this.lst.map(fn))
  // }
  // filter(fn: (obj: T) => boolean): List<T> {
  //   return new List(this.lst.filter(fn))
  // }
}

// import { tagged } from 'daggy'

// const PairFunctor = tagged('PairFunctor', ['$1', '$2'])

// // We just transform the second value!
// // map :: PairFunctor a b ~> (b -> c) -> PairFunctor a c
// PairFunctor.prototype.map = function(f) {
//   return PairFunctor(this.$1, f(this.$2))
// }

class Pair {
  constructor($1, $2) {
    this.$1 = $1;
    this.$2 = $2;
  }
  map(f) {
    var new$2 = f(this.$2);
    return new Pair(this.$1, new$2);
  }
  ap(fs) {
    var new$2 = fs.$2(this.$2);
    return new Pair(fs.$1.concat(this.$1), new$2);
  }
  chain(f) {
    var that = f(this.$2);

    return new Pair(this.$1.concat(that.$1), that.$2);
  }
  static of(x) {
    return new Pair(List.empty(), x);
  }
}

var users = [{
  id: 1,
  hair: 'brown',
  height: 185
}, {
  id: 2,
  hair: 'blonde',
  height: 165
}, {
  id: 3,
  hair: 'blonde',
  height: 181
}, {
  id: 4,
  hair: 'brown',
  height: 175
}, {
  id: 5,
  hair: 'blonde',
  height: 187
}];

function _ref(user) {
  return user.hair === 'blonde';
}

function _ref2(user) {
  return user.height > 180;
}

export var result = Pair.of(List.of(users)).chain(users => new Pair(['Blonde hair'], users.filter(_ref)))

// Keep only the users over 180cm tall
.chain(users => new Pair(['Tall'], users.filter(_ref2)));

// Count the remaining users
// .map(users => users.length)
/*{
  const Pair$: Pair$Type = tagged('Pair$', ['$1', '$2'])

  Pair$.prototype.map = function(f) {
    return Pair$(this.$1, f(this.$2))
  }

  Pair$.prototype.ap = function(fs) {
    return Pair$(fs.$1.concat(this.$1),
                 fs.$2(this.$2))
  }

  Pair$.of = x => Pair$(T.empty(), x)

  Pair$.prototype.chain = function(f) {
    const that = f(this.$2)

    return Pair$(this.$1.concat(that.$1),
                 that.$2)
  }

  return Pair$
}*/

// const PairList = Pair(List)

export default Pair;
//# sourceMappingURL=validator.js.map