
// import type { Monad } from 'flow-static-land/src/Monad'
// import type { Tuple, TupleV } from 'flow-static-land/src/Tuple'
// import type { Pointed } from 'flow-static-land/src/Pointed'
import * as either from 'flow-static-land/lib/Either';
// import { HKT } from 'flow-static-land/lib/HKT'
// import * as tuple from 'flow-static-land/lib/Tuple'

// import Reader from 'fantasy-readers'

// import { traverse } from 'ramda'

import { ErrorSet, Validator, ValidationPair } from './error-list';

function _ref(list) {
  return either.left(list);
}

var doCata = (pair, obj) => pair.second().cata({
  Empty: () => either.of(obj),
  List: _ref
});

var makeErrorCheck = check => obj => check.test(obj) ? ValidationPair.empty(obj) : ValidationPair.of(obj, check.error(obj));

// const makeRightCheck = (check: ErrorChecker) =>
//   (eitherConfig: Either<Config, Config>): ValidationPair => {
//     either.isRight(eitherConfig)
//       ?
//       :
//     either.chain(
//       (obj: Config): ValidationPair =>
//         check.test(obj)
//           ? ValidationPair.empty(either.of(obj))
//           : ValidationPair.of(
//             either.left(obj),
//             check.error(obj)
//           ),
//       eitherConfig
//     )
//   }

export var validatorList = Validator.of([{
  test: config => typeof config.path === 'string',
  error: config => `type of path should be string, get ${typeof config.path}`
}, {
  test: config => typeof config.protocol === 'string',
  error: config => `type of protocol should be string, get ${typeof config.protocol}`
}, {
  test: config => typeof config.port === 'number',
  error: config => `type of port should be number, get ${typeof config.port}`
}, {
  test: config => Array.isArray(config.dcList),
  error: config => `type of dcList should be array, get ${typeof config.dcList}`
}]);

var checkReduce = (acc, checker) => acc.chain(makeErrorCheck(checker));

// const checkReduceStrict =
//   (acc: ValidationPair, checker: ErrorChecker) => acc.chain(makeRightCheck(checker))

var doValidate = validator => obj => {
  var state = ValidationPair.empty(obj);
  var result = validator.reduce(checkReduce, state);
  return doCata(result, obj);
};

// const doValidateSeq = (validator: Validator) =>
//   (obj: Config): ValidatedConfig => {
//     const state = ValidationPair.empty(either.of(obj))
//     const result = validator.reduce(checkReduceStrict, state)
//     return doCata(result, obj)
//   }

var validate = doValidate(validatorList);

export var checkFullServerConfig = validate;

export default validate;
//# sourceMappingURL=server.js.map